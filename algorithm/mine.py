"""
有5个金矿，每个金矿黄金储量不同，需要参与挖掘的工人数目也不同，假定有10个工人，每个金矿要么全挖，
要么不挖，不可以拆分，试问，想得到最多的黄金，应该选择挖取哪几个金矿。
矿井的排序，需要的人数，金子的价值，分别如下：
1号矿的价值是400，需要5个人挖；2号矿的价值是500，需要5个人挖；
3号矿的价值是200，需要3个人挖；4号矿的价值是300，需要4个人挖；5号矿的价值是350，需要3个人挖
https://blog.csdn.net/zhouchen1998/article/details/88742619
"""

# 需要注意的一个坑，就是，下标都是从0开始算起的
def mine(i, n, p, g):
    """
    i, 表示第i座矿，n表示总需要的人数，p[i]表示第i座矿需要的人数，g[i]表示第i座矿的可以挖出来的金子
    R(i, n, p, g)表示总的收益
    """
    # F(n, w) = 0(n <= 1, w < p[0])
    # F(n, w) = G[0](n == 1, w >= P[0])
    # F(n, w) = F(n - 1, w)(n > 1, w < P[n - 1])
    # F(n, w) = max(F(n - 1, w), F(n - 1, w - P[n - 1]) + G[n - 1])(n > 1, w >= P[n - 1])

    if i <= 1 or n < p[0]:
        return 0
    if i == 1 and n >= p[0]:
        return g[0]
    if i > 1 and n < p[i - 1]:
        return mine(i - 1, n, p)
    else:
        return max(mine(i - 1, n, p, g), mine(i - 1, n - p[i - 1], p, g) + g[i - 1])


if __name__ == "__main__":
    i = 5
    n = 10
    p = [5, 5, 3, 4, 3]
    g = [400, 500, 200, 300, 350]
    print(mine(i, n, p, g))
